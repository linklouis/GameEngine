package gameengine.threed.geometry;

import gameengine.vectormath.Vector3D;

public class Plane implements IsPlane {
    private final Vector3D vector1;
    private final Vector3D vector2;

    public Plane(Vector3D vector1, Vector3D vector2) {
        this.vector1 = vector1;
        this.vector2 = vector2;
    }

    public Plane(Vector3D origin, Vector3D point1, Vector3D point2) {
        this.vector1 = point1.subtract(origin);
        this.vector2 = point2.subtract(origin);
    }


    /*
     * Functionality:
     */

    /**
     * Finds the first intersection a lightRay will have with the
     * {@code Collider3D}.
     *
     * @param ray             The lightRay to find a collision with.
     * @param curSmallestDist The largest distance the output is looking for.
     *                        Can be used for optimization by counting out a
     *                        {@code Collider3D} early.
     * @return -1 if never enters range or if collision is behind start.
     * Otherwise, the distance to first hit
     */
    @Override
    public double distanceToCollide(Ray ray, double curSmallestDist) {
        return surfaceNormal().distToCollidePlane(getCenter(), ray.getPosition(), ray.getDirection());
    }

    public Vector3D surfaceNormal() {
        return vector1.crossProduct(vector2);
    }

    /**
     * Returns the normal vector of the intersectable object facing towards the
     * {@code VectorLine}.
     *
     * @param perspective
     * @return
     */
    @Override
    public Vector3D surfaceNormal(Ray perspective) {
        Vector3D normal = surfaceNormal();
        if (normal.dotProduct(perspective.getDirection()) > 0) {
            return normal.scalarMultiply(-1);
        }
        return normal;
    }

    public Vector3D getVector1() {
        return vector1;
    }

    public Vector3D getVector2() {
        return vector2;
    }

    @Override
    public Vector3D getCenter() {
        return null;
    }
}
