typedef struct
{
    int type;

    float4 color;
    float emissionStrength;
    float4 emissionColor;
    float4 emission;

    float otherVars[3];
} Texture;

typedef struct
{
    char type; // 0 = Sphere, 1 = Tri, 2 = Rect

    Texture texture;

    float4 normal;
    float4 vertexOrCenter;

    float4 side1; // v0 for tris, planeXAxis for quads
    float4 side2; // v1 for tris, planeYAxis for quads

    // Tris:
    float dot00; // Also r for spheres
    float dot01;
    float dot11;
    float invDenom;

    // Quads:
    float2 max;
    float2 min;
} RayTraceable;

inline float distanceToCollideSphere(Ray ray, RayTraceable obj) {
    float amountInDirection = dot(ray.direction, ray.position - obj.vertexOrCenter);
    if (amountInDirection <= 0) {
        return -amountInDirection - sqrt(square(amountInDirection) + square(obj.dot00) - distanceSquared(ray.position, obj.vertexOrCenter));
    }
    return -1;
}

inline float distanceToCollideTri(Ray ray, RayTraceable obj) {
    if (dot(obj.normal, ray.direction) > 0) {
        obj.normal *= -1;
    }
    float distance = distToCollidePlane(obj.normal, obj.vertexOrCenter, ray);

    if (distance <= 0) {
        return -1;
    }

    float4 point = ray.position - ray.direction * distance;
    float dot02 = dot(obj.side1, point - obj.vertexOrCenter);
    float dot12 = dot(obj.side2, point - obj.vertexOrCenter);
    // Compute barycentric coordinates
    float u = (obj.dot11 * dot02 - obj.dot01 * dot12);
    float v = (obj.dot00 * dot12 - obj.dot01 * dot02);

    // Check if the point is inside the triangle
    if ((u >= 0) && (v >= 0) && ((u + v) <= obj.invDenom)) {
        return distance;
    }
    return 0/0.0f;
}

inline float distanceToCollideRect(Ray ray, RayTraceable obj) {
    float distance;
    if (dot(obj.normal, ray.direction) > 0) {
        distance = distToCollidePlane(obj.normal * -1, obj.vertexOrCenter, ray);
    } else {
        distance = distToCollidePlane(obj.normal, obj.vertexOrCenter, ray);
    }

    float2 pointOnPlane = projectToPlane(ray, obj.side1, obj.side2, distance);
    //if (obj.min < pointOnPlane && pointOnPlane < obj.max) {
    if (obj.min.x < pointOnPlane.x && obj.max.x > pointOnPlane.x
            && obj.min.y < pointOnPlane.y && obj.max.y > pointOnPlane.y) {
        return distance;
    }
    return -1;
}